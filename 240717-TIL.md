# 240717 - Python 03 Functions
> ## Index
> 
> 1) 파이썬 함수 `Functions` `parameter` `argument`
> 2) 유용한 내장 함수 `map` & `zip`
> 3) 함수와 `scope`, `variable`
> 4) `Packing` & `Unpacking`
> 5) `lambda` 표현식
> ---

<br>

### 1) 파이썬 함수 `Functions` `parameter` `argument`
---
`함수 Functions`란 특정 작업을 수행하기 위한, 재사용 가능한 코드 묶음이다. 우리는 반복되는 특정 작업을 수행하는 함수를 정의하고 사용함으로써 `코드의 중복`을 방지한다. 이를 통해 `재사용성`이 높아지고, 코드의 `가독성`과 `유지보수성`을 향상할 수 있다.
```
함수는 parameter와 body, return value 3가지 요소로 구조를 이룬다. parameter는 input으로 주어지는 입력 값을 가리키며, body는 함수의 설명서 Docstring(선택 사항)과 function body로 구성된다. input 값이 function body의 내용을 수행한 후 반환되는 output이 바로 return value이다.
```

### ✔ 함수 정의와 호출
---

- `함수 정의`
    - def (define) + 함수명(공란 or 매개변수)
    - 함수 body (: 다음 코드 블록)
    - 함수 반환 값 (return 이후, 실행 종료 및 결과 반환)

<br>

- `함수 호출` (*function call*)
    - 함수명(인자*) *argument
    - 인자는 함수 정의 시 작성한 매개변수에 대입됨
    - 함수를 실행하기 위해 함수의 이름을 사용하여 해당 함수의 코드 블록을 실행하는 것

``` python
function_name(arguments)

def make_sum(pram1, pram2):
    """이것은 두 수를 받아
    두 수의 합을 반환하는 함수입니다.
    >>> make_sum(1, 2)
    3
    """
    return pram1 + pram2

result = make_sum(100, 30)
return_value = print(result) # 130
print(return_value) # None # print 함수는 값이 없음


def my_func():
    print('hello')

result = my_func() # hello
print(result) # None
```

<br>

### ✔ `매개변수`와 `인자` -- 여기부터 수정 필요
---

- `여러 개의 값`을 `순서대로` `변경 불가능한` 시퀀스 자료형
- 0개 이상의 객체를 포함하며 데이터 목록을 저장
- 소괄호 `()`로 표기 *(단, 숫자 단일 객체는 `,`와 함께 작성)*
- 데이터는 어떤 자료형도 저장할 수 있음

``` python
my_tuple1 = ()
my_tuple2 = (1,) #숫자 객체 1개뿐일 때 , 필수
my_tuple3 = (1, 2, 3)

# immutable 자료형 튜플
my_tuple = (6, 2, 3)
# TypeError: 'tuple' object does not support item assignment
# my_tuple[0] = 100
```

<br>

> 튜플의 특성
- 불변성을 기반으로 안전한 `다수의 값 전달`, `그룹화`, `다중 할당` 등
- 개발자가 직접 사용하기보다 `파이썬 내부 동작`에서 주로 사용됨

``` python
a, b = (10, 100)

print(a) # 10
print(b) # 100

#파이썬은 쉼표를 튜플 생성자로 사용하니 괄호 생략 가능
a, b = 10, 100
```

<br>

### ✔ range 함수
---
- 연속된 `정수` 시퀀스를 생성하는 `변경 불가능한` 자료형
- 함수 형태의 range: `range(시작 값, 끝 값, 증가 값)`
- `range(n)` : 0부터 `n-1`까지의 숫자 시퀀스
- `range(n, m)` : `n`부터 `m-1`까지의 숫자 시퀀스

<br>

> range 특성
- 증가 값이 없으면 `1씩 증가`
- 증가 값이 `음수`이면 감소, `양수`이면 증가, `0`이면 에러
- 증가 값이 양수이면 시작 값이 끝 값보다 작아야 함
- 증가 값이 음수이면 시작 값이 끝 값보다 커야 함
``` python
range1 = range(10)
range2 = range(1, 13)
print(range1) # range(0, 10)
print(range2) # range(1, 13)

# 리스트로 형 변환 시 데이터 확인 가능
print(list(range1)) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(list(range2)) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

# 주로 반복문과 함께 활용
for i in range(5):
  print('Hello')
```


<br>
<br>

### 2) 유용한 내장 함수 `map` & `zip`
---
### ✔ dictionary (딕셔너리)
---
- `key-value 쌍`으로 이루어진, `순서와 중복이 없는` `(value 값만)변경 가능한` 자료형
- 딕셔너리는 `순서가 없으므로` n번째 요소를 찾는 것 불가능
- 중괄호 `{}`로 표기
- `key`는 `변경 불가능`한 자료형만 사용 가능 *ex. str, int, float, tuple, range, ...*
- `value`는 모든 자료형 사용 가능
``` python
empty_dict = {}
small_dict = {'key': 'value'}
big_dict = {'python': 'py', 'c': ['c', 'c++', 'c#']}
print(empty_dict) # {}
print(small_dict) # {'key': 'value'}
print(big_dict) # {'python': 'py', 'c': ['c', 'c++', 'c#']}

# 딕셔너리는 key에 접근해 value를 얻어 냄
print(big_dict['python']) # py

# 딕셔너리 요소 추가
big_dict['java'] = ['java', 'javascript'] # {'python': 'py', 'c': ['c', 'c++', 'c#'], 'java': ['java', 'javascript']}

# 딕셔너리 요소 변경 (중복 X, 변경 O)
big_dict['python'] = 'python' # {'python': 'python', 'c': ['c', 'c++', 'c#'], 'java': ['java', 'javascript']}
```

<br>

### ✔ set (세트)
---
- `순서와 중복이 없는` `변경 가능한` 자료형
- 세트는 `순서가 없으므로` n번째 요소를 찾는 것 불가능
- 세트는 `중복이 없으므로` 수학에서의 `집합`과 동일한 연산 처리 가능
- 중괄호 `{}`로 표기 *\*단, 빈 세트는 name = set()로 생성*
``` python
empty_set = set()
set1 = {1, 10, 100}
set2 = {1, 1, 1}
print(empty_set) # set()
print(set1) # {1, 10, 100}
print(set2) # {1} # 중복 불가

set1 = {1, 3, 5}
set2 = {1, 2, 3}

# 합집합
print(set1 | set2) # {1, 2, 3, 5}

# 차집합
print(set1 - set2) # {5}

# 교집합
print(set1 & set2) # {1, 3}
```

<br>
<br>


### 3) 함수와 `scope`, `variable`
---

### ✔ None
---
- a = None *\*`N`은 반드시 대문자*
- 값이 'None' `없음`임을 의미

<br>

### ✔ Boolean
---
- `참(True)`과 `거짓(False)`을 표현하는 자료형 *\*`T`, `F`은 반드시 대문자*
- `비교/논리 연산`의 평가 결과로 사용됨
- 주로 `조건/반복문`과 함께 사용
``` python
# None 예제
example = None
print(example) # None

# Boolean 예제
bool1 = True
bool2 = False
print(bool1) # True
print(bool2) # False
print(100 > 99) # True
print('55' != 55) # True
```

<br>

### ✔ Collection
---
- `여러 개의 항목 또는 요소`를 담는 자료 구조
- *str, list, tuple(<span style="color:red">sequence</span>), set, dict(<span style="color:green">none sequence</span>)*

<br>

| Collection Type | 변경 가능 여부 | 순서 여부 |
| :-----: | :---: | :---: |
| str | X | <span style="color:red">O</span> |
| list | O | <span style="color:red">O</span> |
| tuple | X | <span style="color:red">O</span> |
| set | O | <span style="color:green">X</span> |
| dict | O | <span style="color:green">X</span> |


<br>
<br>

### 4) `Packing` & `Unpacking`
---

한 데이터 타입을 다른 데이터 타입으로 변환하는 과정을 `형변환 Type Conversion`이라고 한다. Type Conversion은 `암시적 형변환`과 `명시적 형변환` 2가지로 나뉜다.

### ✔ Implicit Type Conversion `암시적 형변환`
---
- 파이썬이 `자동으로 수행`하는 형변환
- 정수와 실수의 연산에서 `정수가 실수로` 변환됨
``` python
print(3+5.0) # 8.0
```
- `Boolean`과 `Numeric Type`에서만 가능
``` python
print(3+True) # 4 # True = 1
print(5-False) # 5 # False = 0
```

<br>

### ✔ Explicit Type Conversion `명시적 형변환`
---
- 프로그래머가 직접 지정하는 형변환 (암시적 형변환 외 모든 케이스)
- `str → int` : 형식에 맞는 숫자만 가능
- `int → str` : 모두 가능

<br>

#### - 컬렉션 간 형변환 정리 (참고용)

|  | str | list | tuple | range | set | dict |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| str | | O | O | X | O | X |
| list | O | | O | X | O | X |
| tuple | O | O | | X | O | X |
| range | O | O | O | | O | X |
| set | O | O | O | X | | X |
| dict | O | O <br><span style="color:gray">(key만)</span> | O <span style="color:gray"><br>(key만)</span> | X | O <span style="color:gray"><br>(key만)</span> | |

<br>

#### - `복합` 연산자
복합 연산자 사용 시 연산과 할당이 함께 이루어진다.

| 기호 | 예시 | 의미 |
| :---: | :---: | :---: |
| += | a += b | a = a + b |
| -= | a -= b | a = a - b |
| *= | a *= b | a = a * b |
| /= | a /= b | a = a / b |
| //= | a //= b | a = a // b |
| %= | a %= b | a = a % b |
| **= | a **= b | a = a ** b |

<br>

#### - `비교` 연산자

| 기호 | 내용 |
| :---: | :---: |
| < | 미만 |
| <= | 이하 |
| > | 초과 |
| >= | 이상 |
| == | 같음 |
| != | 같지 않음 |
| is | 같음 |
| &nbsp;&nbsp;&nbsp;&nbsp;is not&nbsp;&nbsp;&nbsp;&nbsp; | &nbsp;&nbsp;&nbsp;&nbsp;같지 않음&nbsp;&nbsp;&nbsp;&nbsp; |

<br>

#### - `is` 비교 연산자
- 메모리 내에서 같은 객체를 참조하는지 `주소`까지 확인
- ==는 `동등성(*equality*)`, is는 `식별성(*identity*)`이 특징으로, `is`와 `not is`는 값을 비교하지 않음

``` python
# 비교 연산자
print(29 > 30) # False
print(3.0 == 3) # True
print(2 != 2) # False
print('HELLO' == 'hello') # False
print(1 == True) # True

# is 비교 연산자
print(1 is True) # False
print(3.0 is 3) # False
print(1 == True) # True
print(3.0 == 3) # True
```

<br>

#### - `논리 연산자 & 비교 연산자`

``` python
luck = 4
gift = (luck > 10) and (luck % 2 == 0)
print(gift)  # False
```

<br>

#### - `단축평가`
- 논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작
- 앞에서 결론이 지어지는 경우 `코드 실행을 최적화`하고, 불필요한 연산을 피할 수 있도록 함

``` python
words = 'everywhere'

print(('e' and 'b') in words) # False
print(('b' and 'e') in words) # True

# ('e' and 'b') in words가 False인 이유
# → 전건 'e' in 'everywhere이 참
# → and 뒤 후건으로 이동
# → 후건 'b' in 'everywhere이 거짓
# → 최종적으로 거짓이므로 False

# ('b' and 'e') in words가 True인 이유
# → 전건 'b' in 'everywhere이 거짓
# → and 뒤 후건으로 이동
# → 후건 'e' in 'everywhere이 참
# → 최종적으로 참이므로 True

print(1 and 2) # 2
print(1 and 0) # 0
print(0 and 2) # 0 # 첫 번째 0까지만 단축평가 발생
print(0 and 0) # 0 # 첫 번째 0까지만 단축평가 발생

print(1 or 2) # 1 # 1까지만 단축평가 발생
print(1 or 0) # 1 # 1까지만 단축평가 발생
print(0 or 2) # 1
print(2 or 0) # 2 # 2까지만 단축평가 발생
```

<br>

#### - `멤버십` 연산자
특정 값이 시퀀스나 다른 컬렉션에 `속하는지 여부`를 확인

| 기호 | 내용 |
| :---: | :---: |
| in | 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하는지를 확인 |
| not in | 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하지 않는지를 확인 |

``` python
word = 'friend'
numbers = [1, 10, 100, 1000, 10000]

print('i' in word)  # True
print('z' in word)  # False

print(10 not in numbers)  # False
print(6 not in numbers)  # True
```

<br>

#### - `시퀀스형` 연산자
> `+`와 `*`는 `시퀀스 간 연산`에서 산술 연산자일 때와 다른 역할을 가짐
> 
> \+ `결합 연산자`
> 
> \* `반복 연산자`
``` python
print('Play' + ' Game')  # Play Game
print('Hello' * 5)  # HelloHelloHelloHelloHello

print([1, 5] + ['x', 'y'])  # [1, 5, 'x', 'y']
print([1, 0] * 2)  # [1, 0, 1, 0]
```


<br>
<br>

### 5) `lambda` 표현식
---

한 데이터 타입을 다른 데이터 타입으로 변환하는 과정을 `형변환 Type Conversion`이라고 한다. Type Conversion은 `암시적 형변환`과 `명시적 형변환` 2가지로 나뉜다.

### ✔ Implicit Type Conversion `암시적 형변환`
---
- 파이썬이 `자동으로 수행`하는 형변환
- 정수와 실수의 연산에서 `정수가 실수로` 변환됨
``` python
print(3+5.0) # 8.0
```
- `Boolean`과 `Numeric Type`에서만 가능
``` python
print(3+True) # 4 # True = 1
print(5-False) # 5 # False = 0
```

<br>

### ✔ Explicit Type Conversion `명시적 형변환`
---
- 프로그래머가 직접 지정하는 형변환 (암시적 형변환 외 모든 케이스)
- `str → int` : 형식에 맞는 숫자만 가능
- `int → str` : 모두 가능

<br>

#### - 컬렉션 간 형변환 정리 (참고용)

|  | str | list | tuple | range | set | dict |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| str | | O | O | X | O | X |
| list | O | | O | X | O | X |
| tuple | O | O | | X | O | X |
| range | O | O | O | | O | X |
| set | O | O | O | X | | X |
| dict | O | O <br><span style="color:gray">(key만)</span> | O <span style="color:gray"><br>(key만)</span> | X | O <span style="color:gray"><br>(key만)</span> | |

<br>

#### - `복합` 연산자
복합 연산자 사용 시 연산과 할당이 함께 이루어진다.

| 기호 | 예시 | 의미 |
| :---: | :---: | :---: |
| += | a += b | a = a + b |
| -= | a -= b | a = a - b |
| *= | a *= b | a = a * b |
| /= | a /= b | a = a / b |
| //= | a //= b | a = a // b |
| %= | a %= b | a = a % b |
| **= | a **= b | a = a ** b |