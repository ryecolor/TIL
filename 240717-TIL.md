# 240717 - Python 03: Functions
> ## Index
> 
> 1) 파이썬 함수 `Functions` `parameter` `argument`
> 2) 유용한 내장 함수 `map` & `zip`
> 3) 함수와 `scope`, `variable`
> 4) `Packing` & `Unpacking`
> 5) `lambda` 표현식
> ---

<br>

### 1) 파이썬 함수 `Functions` `parameter` `argument`
---
`함수 Functions`란 특정 작업을 수행하기 위한, 재사용 가능한 코드 묶음이다. 우리는 반복되는 특정 작업을 수행하는 함수를 정의하고 사용함으로써 `코드의 중복`을 방지한다. 이를 통해 `재사용성`이 높아지고, 코드의 `가독성`과 `유지보수성`을 향상시킬 수 있다.
``` python
함수는 'parameter'와 'body', 'return value' 3가지 요소로 구조를 이룬다. 'parameter'는 input으로 주어지는 입력 값을 가리키며, 'body'는 함수의 설명서 Docstring(선택 사항)과 function body로 구성된다. input 값이 function body의 내용을 수행한 후 반환되는 output 값이 바로 'return value'이다.
```

### ✔ 함수 정의와 호출
---

- `함수 정의`
    - def (*define*) + 함수명(공란 or 매개변수)
    - 함수 body (: 다음 코드 블록)
    - 함수 반환 값 (return 이후, 실행 종료 및 결과 반환)

<br>

- `함수 호출` (*function call*)
    - 함수명(인자*) *\*argument*
    - 인자는 함수 정의 시 작성한 매개변수에 대입됨
    - 함수를 실행하기 위해 함수의 이름을 사용하여 해당 함수의 코드 블록을 실행하는 것

``` python
function_name(arguments)

def make_sum(param1, param2):
    return param1 + param2

result = make_sum(6, 24)
return_value = print(result) # 30
print(return_value) # None # print() 함수는 리턴 값이 없음


def my_func():
    print('python')

result = my_func() # python
print(result) # None # print() 함수는 리턴 값이 없음
```

> ▶ `print() 값`과 `return`의 차이
``` python
우리가 자주 사용하는 print()는 return 값 없이, 명령을 수행한 후 프롬프트에 출력하는 하나의 함수이다. 따라서 print() 함수 자체의 값을 반환하면 그 값 출력이 값이 없는 None 으로 출력된다. 함수마다 print() 결과와 return 값을 명확히 구분하여야 함을 주의하자.
```

<br>

### ✔ `매개변수`와 `인자`
---

`매개변수 parameter`
- 함수를 정의할 때, 함수가 받을 값을 나타내는 변수
- 매개변수는 지정된 의미가 없으며, 함수의 동작에 영향을 주지 않음


`인자 argument`
- 함수를 호출할 때, 실제로 전달되는 값

<br>

- 다양한 인자 종류
  - `위치 인자 (Positional Arguments)`
    - 함수 호출 시 인자의 위치에 따라 전달되는 인자
    - 위치 인자는 함수 호출 시 반드시 값을 전달해야 하며, 누락 시 에러 발생
``` python
def be_happy(name, date, time='오전'):
    if time == '오전':
        print(f'{name}님, {date} 오늘 하루도 행복해지세요!')
    elif time == '오후':
        print(f'{name}님, {date} 오늘 하루도 행복하셨나요?')

be_happy('예진') # TypeError: be_happy() missing 1 required positional argument: 'date'
```

<br>

  - `기본 인자 값 (Default Argument Values)`
    - 함수 정의에서 매개변수에 기본 값을 할당하는 것
    - 함수 호출 시 인자를 전달하지 않으면, 기본 값이 매개변수에 할당됨
``` python
def be_happy(name, date, time='오전'):
    if time == '오전':
        print(f'{name}님, {date} 오늘 하루도 행복해지세요!')
    elif time == '오후':
        print(f'{name}님, {date} 오늘 하루도 행복하셨나요?')

be_happy('예진', '7월 18일') # 입력 없이도 기본 인자 값 수행 # 예진님, 7월 18일 오늘 하루도 행복해지세요!
be_happy('예진', '7월 18일', '오후') # 입력이 있으므로 입력 값대로 수행 # 예진님, 7월 18일 오늘 하루도 행복하셨나요?
```

<br>

  - `키워드 인자 (Keyword Arguments)`
    - 함수 호출 시 인자의 이름과 함께 값을 전달하는 인자
    - 매개변수와 인자를 일치시키지 않고, 특정 매개변수에 값을 할당할 수 있음
    - 인자의 순서는 중요하지 않으며, 인자의 이름을 명시하여 전달
    - 단, 호출 시 키워드 인자는 *위치 인자 뒤*에 위치해야 함
``` python
def be_happy(name, date, time='오전'):
    if time == '오전':
        print(f'{name}님, {date} 오늘 하루도 행복해지세요!')
    elif time == '오후':
        print(f'{name}님, {date} 오늘 하루도 행복하셨나요?')

be_happy(date='7월 18일', name='예진', time='오후') # 예진님, 7월 18일 오늘 하루도 행복하셨나요?
be_happy('예진', time='오전', date='7월 18일') # 예진님, 7월 18일 오늘 하루도 행복해지세요!
```

<br>

  - `임의의 인자 목록 (Arbitrary Argument Lists)`
    - 정해지지 않은 개수의 인자를 처리하는 인자
    - 함수 정의 시 매개변수 앞에 '*'를 붙여 사용하며, 여러 인자를 `tuple`로 처리
    - 매개변수 작성 시 *위치 인자를 임의의 인자 목록 앞*에 기재
``` python
def sum_of_favorites(*args):
    sof = sum(args)
    print(type(args)) # <class 'tuple'>
    print(sof)

sum_of_favorites(0, 6, 2, 4) # 12
```

<br>

  - `임의의 키워드 인자 목록 (Arbitrary Keyword Argument Lists)`
    - 정해지지 않은 개수의 키워드 인자를 처리하는 인자
    - 함수 정의 시 매개변수 앞에 '**'를 붙여 사용하며, 여러 인자를 `dictionary`로 묶어 처리
``` python
def dict_of_favorites(**kwargs):
    print(type(kwargs)) # <class 'dict'>
    print(kwargs)

dict_of_favorites(artist='Daymons Year', song='Yours') # {'artist': 'Daymons Year', 'song': 'Yours'}
```

<br>
<br>

> ### **함수 인자 권장 작성 순서**
> ---
> - 위치 → 기본 → 가변 → 가변 키워드
> - 호출 시 인자를 전달하는 과정에서 혼란을 줄일 수 있도록 함
> - 단, 모든 상황에 적용되는 절대적인 규칙은 아니며, 상황에 따라 유연하게 조정될 수 있음
``` python
def func(pos1, pos2, default_arg='default', *args, **kwargs):
    print('pos1:', pos1)
    print('pos2:', pos2)
    print('default_arg:', default_arg)
    print('args:', args)
    print('kwargs:', kwargs)

func(1, 2, 3, 4, 5, 6, key1='value1', key2='value2')

# pos1: 1
# pos2: 2
# default_arg: 3
# args: (4, 5, 6)
# kwargs: {'key1': 'value1', 'key2': 'value2'}
```

<br>

### ✔ 재귀 함수
---
- 함수 내부에서 `자기 자신`을 호출하는 함수
- 재귀 함수 예시: `factorial(!)`
  - n! = n*(n-1)*(n-2)*(n-3)*...
  - 자기 자신을 재귀적으로 호출하여 입력된 숫자 n의 팩토리얼을 계산
  - 재귀 호출은 n이 0이 될 때까지 반복되며, 종료 조건을 설정하여 재귀 호출이 멈추도록 함
  - 재귀 호출의 결과를 이용하여 문제를 작은 단위의 문제로 분할하고, 분할된 문제들의 결과를 조합하여 최종 결과를 도출
``` python
def factorial(n):
    # 종료 조건 설정: n이 0이면 1 반환
    if n == 0:
        return 1
    else:
        # 재귀 호출: n과 n-1의 팩토리얼을 곱한 결과 반환
        return n * factorial(n - 1)

print(factorial(5))  # 120
```
<br>

> **재귀 함수 특징**
- 특정 알고리즘 식을 표현할 때 변수의 사용이 줄어들며, `코드의 가독성`이 높아짐
- 1개 이상의 `base case(종료되는 상황)`가 존재하고, 수렴하도록 작성

> **재귀 함수 주의점**
- `종료 조건`을 명확히 할 것
- 반복되는 호출이 종료 조건을 향하도록 할 것

<br>

### ✔ 내장 함수 Built-in function
---
- 파이썬이 기본적으로 제공하는 함수
- 별도의 import 없이 바로 사용 가능한 함수

``` python
numbers = [1, 2, 3, 4, 5]

print(len(numbers))  # 5 # 함수 길이
print(max(numbers))  # 5 # 최댓값
print(min(numbers))  # 1 # 최솟값
print(sum(numbers))  # 15 # 합
print(sorted(numbers, reverse=True))  # [5, 4, 3, 2, 1]
# 내림차순(reverse)으로 정렬(sorted)
# slicing [::-1]과 sorted(x, reverse=True)는 다름 (정렬인 것과 정렬이 아닌 것)
```

<br>
<br>

### 2) 유용한 내장 함수 `map` & `zip`
---
### ✔ map(function, iterable)
---
- `순회 가능한` 데이터 구조(iterable)의 `모든 요소에 함수를 적용`하고, 그 결과를 map object로 반환
- `iterable`: 반복 가능한 객체(요소) Ex. collection, ...

``` python
# map
numbers = [1, 2, 3]
result = map(str, numbers)
print(result)  # <map object at 0x00000239C915D760> # map() 바로 출력 불가
print(list(result))  # ['1', '2', '3'] # numbers의 숫자들을 하나씩 문자열로 바꿈

numbers1 = input().split()
print(numbers1)  # ['1', '2', '3'] # 1, 2, 3 입력 시 하나의 튜플로 받아 문자열 리스트로 반환

numbers2 = list(map(int, input().split()))
print(numbers2)  # [1, 2, 3] # 1 2 3 입력 시 하나의 문자열을 분리해 정수화하여 리스트로 반환
```

<br>

### ✔ zip(*iterables)
---
- 임의의(*) iterable을 모아 `튜플`을 원소로 하는 zip object를 반환
- 2차원 리스트(리스트 내부에 리스트가 포함된 형태)의 `같은 컬럼(열) 요소`를 동시에 조회할 때
``` python
# zip
girls = ['Lee', 'Yejin']
boys = ['Park', 'Eun-a']
pair = zip(girls, boys)
print(pair)  # <zip object at 0x000001C76DE58700>
print(list(pair))  # [('Lee', 'Park'), ('Yejin', 'Eun-a')]

kr_scores = [10, 20, 30, 50]
math_scores = [20, 40, 50, 70]
en_scores = [40, 20, 30, 50]

for student_scores in zip(kr_scores, math_scores, en_scores):
    print(student_scores)

# (10, 20, 40)
# (20, 40, 20)
# (30, 50, 30)
# (50, 70, 50)

scores = [
    [10, 20, 30],
    [40, 50, 40],
    [20, 40, 50],
]
for score in zip(*scores):
    print(score)

# (10, 40, 20)
# (20, 50, 40)
# (30, 40, 50)
```

<br>
<br>


### 3) 함수와 `scope`, `variable`
---

### ✔ Python의 범위, Scope
---
- 함수는 코드 내부에 local scope를 생성하며, 그 외의 공간인 global scope로 구분
- `scope`
  - global scope: 코드 어디에서든 참조할 수 있는 공간
  - local scope: 함수가 만든 scope (함수 내부에서만 참조 가능)
- `variable`
  - global variable: global scope에 정의된 변수
  - local variable: local scope에 정의된 변수
- `변수 수명주기(lifecycle)`
  - 변수의 수명주기는 **변수가 선언되는 위치**와 **scope**에 따라 결정됨
    - `built-in scope`: 파이썬이 실행된 이후부터 영원히 유지
    - `global scope`: 모듈이 호출된 시점 이후 혹은 인터프리터가 끝날 때까지 유지
    - `local scope`: 함수가 호출될 때 생성되고, 함수가 종료될 때까지 유지

<br>

### ✔ 이름 검색 규칙 (Name Resolution)
---
- 파이썬에서 사용되는 `이름(식별자)`들은 특정한 `이름공간(namespace)`에 저장되어 있음
- 아래와 같은 순서로 이름을 찾아 나가며, `LEGB Rule`​이라고 부름

> - `Local scope`: 지역 범위 (현재 작업 중인 범위)
> - `Enclosed scope`: 지역 범위 한 단계 위 범위
> - `Global scope`: 최상단에 위치한 범위
> - `Built-in scope`: 모든 것을 담고 있는 범위 (정의하지 않고 사용할 수 있는 모든 것)

<br>

![scope_image](https://github.com/ragu6963/TIL/assets/32388270/15b4f0c6-7f21-4986-8349-fd8740e49573)

<br>

- 함수 내에서는 global 키워드를 통해 바깥 Scope의 변수에 `접근 가능`하나, `수정 불가`

> - 변수의 scope를 전역 범위로 지정하기 위해 사용
> - 일반적으로 함수 내에서 전역 변수를 수정하려는 경우에 사용
> - `global 키워드 선언` 전에 참조 불가
> - 매개변수는 global 키워드 사용 불가

<br>

- **LEGB Rule 예시**

> - sum을 global scope에서 사용하면 기존 built-in scope에 있던 내장 함수 sum을 사용하지 못함
> - sum을 참조 시 LEGB Rule에 따라 global에서 먼저 찾기 때문
``` python
a = 1
b = 2


def enclosed():
    a = 10
    c = 3

    def local(c):
        print(a, b, c)  # 10 2 500 # c는 매개변수일 뿐 # 구분 확실히 할 것

    local(500)
    print(a, b, c)  # 10 2 3


enclosed()

print(a, b)  # 1 2
```

<br>
<br>

### 4) `Packing` & `Unpacking`
---

### ✔ `Packing 패킹`
---
- 여러 개의 값을 하나의 변수에 묶어서 담는 것
- 변수에 담긴 값들은 `튜플(tuple) 형태`로 묶임

<br>

### ✔ `Unpacking 언패킹`
---
- 패킹된 변수의 값을 개별적인 변수로 `분리하여 할당`하는 것
- 튜플이나 리스트 등 객체의 요소들을 개별 변수에 할당

<br>

### ✔ `*(Asterisk)` 활용법
---
1) `*`를 활용한 패킹
   - 매개변수에 쓰이는 *처럼, 여러 개의 인자를 하나의 튜플로 묶음

2) `*`를 활용한 언패킹
   - `인자 앞`에 쓰일 때, 시퀀스나 반복 가능한 객체를 각각의 요소로 언패킹하여 함수 인자로 전달

3) `**`를 활용한 언패킹
   - `인자 앞`에 쓰일 때, 딕셔너리의 키-값 쌍을 언패킹하여 함수의 키워드 인자로 전달
   - 단, 함수 내 매개변수와 딕셔너리의 `키가 동일`해야 함


<br>
<br>

### 5) `lambda` 표현식
---

`람다 표현식(Lambda expressions)`은 익명 함수를 만드는 것에 사용되는 표현식으로, 한 줄로 간단히 일회성 함수를 정의할 때 사용한다.

> - `lambda 매개변수: 표현식`의 구조
>   - `lambda` : 람다 함수를 선언하기 위해 사용되는 키워드
>   - `매개변수` : 함수에 전달되는 매개변수들 (다수일 경우, `쉼표`로 구분)
>   - `표현식` : 함수의 실행되는 코드 블록으로, `결과값`을 반환하는 표현식으로 작성
``` python
def addition(x, y):
    return x + y

result = addition(3, 5)
print(result)  # 8


# lambda 표현식으로 작성한 addition 함수
addition = lambda x, y: x + y

result = addition(3, 5)
print(result) # 8

# with map 함수
numbers = [1, 2, 3, 4, 5]


def square(x):
    return x**2


# lambda 미사용
squared1 = list(map(square, numbers))
print(squared1)  # [1, 4, 9, 16, 25]

# lambda 사용
squared2 = list(map(lambda x: x**2, numbers))
print(squared2) # [1, 4, 9, 16, 25]
```