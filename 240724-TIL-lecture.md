# 240724 - Python 07: OOP 1
> ## Index
> 
> 1) 객체 지향 프로그래밍 `OOP`
> 2) `클래스`와 `객체`, `인스턴스`
> 3) 클래스 `정의` 및 `구조`
> 4) 파이썬 메서드 : `클래스 메서드` `인스턴스 메서드` `스태틱 메서드`
> 5) 보조 메서드 : `매직 메서드` `데코레이터`
> ---

<br>

### 1) 객체 지향 프로그래밍 `OOP`
---
프로그래밍 패러다임은 `절차 지향` 방식에서 `객체 지향` 방식으로 변화하였다. 각각의 방식의 특징과 차이에 대해 알아보자.

<br>

> ① 절차 지향 프로그래밍 `Procedural Programming, PP`

- 프로그램을 `데이터`와 `절차`로 구성하는 방식의 프로그래밍 패러다임

- 코드의 순차적인 흐름과 함수 호출에 의해 프로그램이 진행

- `데이터`와 해당 데이터를 처리하는 `함수(절차)`가 분리되어 있으며, `함수 호출의 흐름`이 중요

- '실제로 `실행되는 내용`이 무엇인가'가 중요

- 데이터를 다시 재사용하기보다 처음부터 끝까지 `실행되는 결과물`이 중요한 방식

<br>

---

<br>

> ② 객체 지향 프로그래밍 `Object Oriented Programming, OPP`

- 등장 배경: `소프트웨어 위기 (Software Crisis)`

  - `하드웨어의 발전`으로 컴퓨터 계산 용량과 문제의 복잡성이 급격히 증가함에 따라 소프트웨어에 발생한 충격

- `데이터`와 해당 데이터를 조작하는 `메서드`를 `​하나의 객체`​로 묶어 관리하는 방식

- 함수보다 `데이터`가 중요해진 프로그래밍 패러다임

<br>

---

<br>

> ③ 절차 지향 vs. 객체 지향

| 절차 지향 (PP) | 객체 지향 (OPP) |
| :-----: | :---: |
| `데이터`와 해당 데이터를 처리하는 `함수(절차)`가 `분리`되어 있는 형태의 프로그래밍 패러다임 | `데이터`와 해당 데이터를 처리하는 `메서드(메시지)`를 `하나의 객체(클래스)`로 묶음 |
| 함수 호출의 흐름이 중요 | 객체 간 상호작용과 메시지 전달이 중요 |


<br>
<br>

### 2) `클래스`와 `객체`, `인스턴스`
---

> `클래스 Class` (= 데이터 타입​)

- 파이썬에서 `타입`을 표현하는 방법

- 객체를 생성하기 위한 설계도

- 데이터와 기능을 함께 묶는 방법을 제공

<br>

> `객체 Object`

- 클래스에서 정의한 것을 토대로 `메모리에 할당된 것`

- `속성(변수)`과 `행동​(메서드)`으로 구성된 모든 것

- `객체 (Object)` = `속성(Attribute)` + `기능(Method)`

  - `타입(type)` : 어떤 연산자(*operator*)와 조작(*method*)이 가능한가?

  - `속성(attribute)` : 어떤 상태(데이터)를 가지는가?

  - `조작법(method)` : 어떤 행위(함수)를 할 수 있는가?

<br>

> `인스턴스 Instance`

- 클래스의 속성과 행동을 기반으로 생성된 개별 객체

- 가수 (클래스) → 아이유, BTS, ... (객체)

  ``` python
  IU는 '객체'다. (O)
  IU는 '인스턴스'다. (X)
  IU는 '가수의 인스턴스'다. (O, 관계적 명시 중요)
  ```

<br>

### "하나의 `객체(Object)`는 특정 타입의 `인스턴스(instance)`이다."

<br>
<br>


### 3) 클래스 `정의` 및 `구조`
---
클래스를 정의하기 위해서는 가장 먼저 `class` 키워드를 사용한다. 또한 다른 함수 정의와 구분하기 위해 `Pascal Case` 방식으로 클래스명을 작성한다.

``` python
'Pascal Case 방식': 대문자로 시작하며, snake_case의 underscore 대신 다시 대문자를 사용 (= Upper Camel Case)
```

<br>

> 클래스 정의

``` python
# class 클래스명
class MyClass:
  number_of_people = 0 # 클래스 변수 (= 클래스 속성)
  class_name = '2반'

  # 클래스 내 모든 함수는 인스턴스 메서드

  # 생성자(클래스) 메서드
  def __init__(self, name): # self = 인스턴스
    #초기 값 필요
    self.name = name # 인스턴스.인스턴스 변수명 = 함수의 매개변수명
    MyClass.number_of_people += 1 # 함수 내에서 클래스 변수 사용 시 클래스명.클래스 변수

  def hello(self): # 인스턴스 메서드
    return f'{self.name}이 입실하였습니다.'
```

<br>

> 인스턴스 생성 및 활용

``` python
# 인스턴스 생성

  # 생성자 메서드에서 인스턴스 self만 요구할 경우
  yejin = MyClass()

  # 생성자 메서드에서 별도의 초기 값 요구할 경우 (Ex. self, age)
  yejin = MyClass(25)


# 메서드 호출

  # 호출 형식
  yejin.메서드()

  # 호출 예시
  print(yejin.hello()) # yejin이 입실하였습니다.


# 속성(변수) 접근
yejin.attribute
  
  # 속성 확인
  print(yejin.class_name) # '2반'

  # 인스턴스 속성(변수)
  print(yejin.age) # 25 # yejin만 가지는 인스턴스 변수
```

<br>

### ✔ 해시 테이블 `Hash Table`
---
> 클래스 구성 요소

- 클래스 구조

  - `생성자 메서드`
    - 객체를 생성할 때 자동으로 호출되는 특별한 메서드 (매직 메서드의 한 종류)
    - `__init__`이라는 이름의 메서드로 정의되며, 객체의 초기화를 담당
    - 생성자 함수를 통해 인스턴스를 생성하고 필요한 초기 값을 설정

  - `인스턴스 변수`
    - 인스턴스(객체)마다 별도로 유지되는 변수
    - 인스턴스마다 독립적인 값을 가지며, 인스턴스가 생성될 때마다 초기화됨

  - `클래스 변수` (= 클래스 속성)
    - 클래스 내부에 선언된 변수 (메서드에 속해 있지 않음)
    - 클래스로 생성된 모든 인스턴스들이 공유하는 변수

  - `인스턴스 메서드`
    - 각각의 인스턴스에서 호출할 수 있는 메서드
    - 인스턴스 변수에 접근하고 수정하는 등의 작업을 수행

<br>

> 인스턴스 변수와 클래스 변수

- 클래스 변수 활용

  - 인스턴스가 생성될 때마다 클래스 변수가 늘어나도록 설정 가능

  - `class.class_variable`로 클래스 변수 참조 가능

  - 인스턴스 변수 `class.class_variable`를 따로 정의할 경우, 클래스 변수에 영향을 미치지는 못함

<br>
<br>

### 4) 파이썬 메서드 : `인스턴스 메서드` `클래스 메서드` `스태틱 메서드`
---

### ✔ 인스턴스 메서드 `Instance Methods`
---

- 핵심 요약

> Most Common

> Must have self parameter

> No decorator needed

> Can be accessed through object (instance of Class)

---

<br>

- 클래스로부터 생성된 각 인스턴스에서 호출할 수 있는 메서드

- 인스턴스의 상태를 조작하거나 동작을 수행

- 데이터를 효율적으로 저장하고 검색하기 위해 사용

<br> ----------- 여기부터 수정

> 해시 테이블 원리
- `해시 함수`를 통해 `키`를 `해시 값`으로 변환하고, 이 해시 값을 `인덱스`로 사용하여 데이터를 저장하거나 검색
- 파이썬 환경이 바뀌며 해시 함수를 재구성할 때마다 `값이 바뀜`

<br>

> 해시 (Hash)
- 임의의 크기를 가진 데이터(key)를 고정된 크기의 `고유한 값(index, 색인)`으로 변환하는 것
- 데이터를 고유하게 식별하는 일종의 `지문`과 같은 역할 수행
- 파이썬에서는 해시 함수를 사용하여 데이터를 `정수` 형태의 해시 값으로 변환

<br>

> 해시 함수 (Hash function)
- 임의의 길이의 데이터를 입력받아 고정된 길이의 `임의의 데이터(해시 값)`를 출력하는 함수
  - 주로 해시 테이블 자료 구조에 사용
  - 매우 빠른 데이터 검색을 위한 컴퓨터 소프트웨어에서 유용하게 사용

<br>

> `set의 요소` & `dictionary의 키`와 `해시 테이블`의 관계
- 파이썬에서 set의 요소와 dictionary의 키는 해시 테이블을 이용하여 중복되지 않는 고유한 값을 저장
- `세트 내의 각 요소`
  - 해시 함수를 통해 해시 값으로 변환되고, 이 해시 값을 기반으로 해시 테이블에 저장
- `딕셔너리의 키`
  - 키는 고유해야 하므로, 키를 해시 함수를 통해 해시 값으로 변환하여 해시 테이블에 저장
  - 딕셔너리의 키는 매우 빠른 탐색 속도를 제공하며, 중복된 값을 허용하지 않음

<br>

> 파이썬에서의 해시 함수
- 파이썬에서 해시 함수의 동작 방식은 `객체의 타입`에 따라 달라짐
- 정수와 문자열은 서로 다른 타입이며, 이들의 해시 값을 계산하는 방식도 다름
- `정수`
  - 같은 정수는 항상 `같은 해시 값`을 가짐
  - 해시 테이블에 정수를 저장할 떄 효율적인 방법
  - 예를 들어, hash(1)과 hash(2)는 항상 서로 다른 해시 값을 갖지만, hash(1)은 항상 동일한 해시 값을 갖게 됨
  - 따라서 파이썬을 여러 번 재실행해도 정수는 같은 해시 값과 순서를 보임
  - 그러나 set, dictionary에 정수만 존재해도 순서가 있다고 볼 수 없음

- `문자열`
  - 문자열은 `가변적`인 길이를 갖고 있음
  - 문자열에 포함된 각 문자들의 유니코드 코드 포인트 등을 기반으로 해시 값 계산
  - 이로 인해 문자열의 해시 값은 실행 시마다 다르게 계산됨

<br>

---

### 정수와 문자열의 `해시 함수 영향` 예시
---
``` python
# 정수
my_set = {3, 2, 1, 9, 100, 4, 87, 39, 10, 52}
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set)


# 문자열
my_str_set = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}
print(my_str_set.pop())
print(my_str_set.pop())
print(my_str_set.pop())
print(my_str_set.pop())
print(my_str_set.pop())

print(hash(1))
print(hash(1))
print(hash('a'))
print(hash('a'))

print(hash(1))
print(hash(1.0))
print(hash('1'))
print(hash((1, 2, 3)))
```
<br>

> `set의 pop() 메서드`의 결과와 `해시 테이블`의 관계
- set의 pop()에서 임의의 요소를 제거하고 반환
- 실행할 때마다 다른 요소를 얻는다는 의미에서의 무작위가 아니라 `임의`라는 의미에서 무작위
  - By "arbitrary" the docs don't mean "random" - python 공식 문서
- 해시 테이블에 나타나는 순서대로 반환하는 것
- `해시 테이블의 순서와 자료 구조상의 순서​를 동일시하면 안 됨`

<br>

> `hashable`
- hash() 함수의 인자로 전달해서 결과를 반환받을 수 있는 객체
- **대부분의** 불변형 데이터 타입은 hashable
- 단, tuple의 경우 불변형이지만 해시 불가능한 객체를 참조할 때는 tuple 자체의 해시도 불가능

<br>

> `hashable`과 `불변성` 간의 관계
- 해시 테이블의 키는 `불변`해야 함 (객체 생성 후 값의 변경이 불가해야 함)
- 불변 객체는 해시 값이 변하지 않으므로 동일한 값에 대해 일관된 해시 값 유지 가능
- 단, hash 가능하다 `!=` 불변하다

<br>

> `가변형` 객체가 `hashable`하지 않은 이유
- 해시 테이블의 `무결성 유지 불가`
  - 값이 변경될 수 있기 때문에 동일한 객체에 대한 해시 값이 변경될 가능성 존재
- 해시 값의 `일관성 유지 불가`
  - 가변형 객체가 변경되면 해시 값이 변경되기 때문에, 같은 객체에 대한 서로 다른 해시 값이 반환될 수 있음

<br>

``` python
TypeError: unhashable type: 'list'
print(hash((1, 2, [3, 4])))
TypeError: unhashable type: 'list'
print(hash([1, 2, 3]))
TypeError: unhashable type: 'list'
my_set = {[1, 2, 3], 1, 2, 3, 4, 5}
TypeError: unhashable type: 'set'
my_dict = {{3, 2}: 'a'}

# 전체 에러 발생
```

<br>

> `hashable` 객체가 필요한 이유
1. `해시 테이블 기반 자료 구조` 사용
   - set의 요소와 dict의 key
   - 중복 값 방지
   - 빠른 검색과 조회

2. `불변성`을 통한 일관된 해시 값

3. `안전성`과 `예측 가능성` 유지

<br>
<br>

### 5) 보조 메서드 : `매직 메서드` `데코레이터`
---

- `BNF(Backus-Naur Form)`
  - 프로그래밍 언어의 문법을 표현하기 위한 표기법

- `EBNF(Extended Backus-Naur Form)`
  - BNF를 확장한 표기법
  - `메타 기호`를 추가하여 더 간결하고 표현력이 강해진 형태
  - 서로 다른 프로그래밍 언어, 데이터 형식, 프로토콜 등의 문법을 통일하여 정의하기 위해 사용


<br>
<br>

### 참고 링크
---
[More Dictionary Method - Python 3.9.19 documentation](https://docs.python.org/3/library/stdtypes.html#dict)